class y{constructor(){this.listeners={}}on(e,t){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(t)}off(e,t){const r=this.listeners[e];r&&(this.listeners[e]=r.filter(n=>n!==t))}emit(e,t){const r=this.listeners[e];r&&r.forEach(n=>{try{n(t)}catch(i){console.error(`Error in event listener for ${String(e)}:`,i)}})}}function w(s,e=1e3,t=3e4){const r=e*Math.pow(2,s),n=Math.min(r,t),i=Math.random()*100;return Math.min(n+i,t+100)}class E{constructor(e,t,r={}){this.events=new y,this._isSyncing=!1,this.queue=e,this.network=t,this.config=r,this.network.onNetworkChange(n=>{n&&this.startSync()})}get isSyncing(){return this._isSyncing}async startSync(){if(!this._isSyncing&&this.network.isOnline()){this._isSyncing=!0,this.events.emit("sync:start",void 0);try{for(;this.network.isOnline();){const e=await this.queue.peekNextRequest();if(!e){this.events.emit("queue-empty",void 0);break}const{item:t,key:r}=e;try{await this.processRequest(t),await this.queue.dequeueRequest(r),this.events.emit("request-success",{id:t.id,response:"OK",item:t})}catch(n){if(n.status===401&&this.config.refreshToken)try{await this.config.refreshToken();continue}catch(i){console.error("Refresh token failed, marking request as permanent error:",t.id,i),await this.queue.dequeueRequest(r),this.events.emit("request-error",{id:t.id,error:i,permanent:!0,item:t});continue}if(this.isPermanentError(n))console.error("Permanent error, discarding request:",t.id,n),await this.queue.dequeueRequest(r),this.events.emit("request-error",{id:t.id,error:n,permanent:!0,item:t});else{t.retryCount=(t.retryCount||0)+1;const i=this.config.maxRetries||5;if(t.retryCount>i)console.error(`Max retries (${i}) exceeded for request:`,t.id,n),await this.queue.dequeueRequest(r),this.events.emit("request-error",{id:t.id,error:n,permanent:!0,item:t});else{await this.queue.updateRequest(r,t);const o=w(t.retryCount,this.config.backoffFactor||1e3);await new Promise(c=>setTimeout(c,o))}}}}}finally{this._isSyncing=!1,this.events.emit("sync:end",void 0)}}}async processRequest(e){const t=await fetch(e.url,{method:e.method,headers:e.headers,body:e.body});if(!t.ok)throw{status:t.status,statusText:t.statusText};return t}isPermanentError(e){return e&&typeof e.status=="number"?e.status>=400&&e.status<500&&e.status!==401&&e.status!==429:!1}}let a=null,u="";function m(s,e){return new Promise((t,r)=>{if(typeof indexedDB>"u")return r(new Error("indexedDB is not defined"));if(a&&a.name===s&&a.objectStoreNames.contains(e))return t();const n=indexedDB.open(s,2);n.onupgradeneeded=i=>{const o=i.target.result;let c;o.objectStoreNames.contains(e)?c=i.target.transaction.objectStore(e):c=o.createObjectStore(e,{autoIncrement:!0}),c.indexNames.contains("priority_idx")||c.createIndex("priority_idx","priority",{unique:!1})},n.onsuccess=i=>{a=i.target.result,u=e,t()},n.onerror=i=>{r(i.target.error)}})}function p(s){return new Promise((e,t)=>{if(!a)return t(new Error("Database not initialized"));const i=a.transaction(u,"readwrite").objectStore(u).add(s);i.onsuccess=()=>e(i.result),i.onerror=()=>t(i.error)})}function x(){return new Promise((s,e)=>{if(!a)return e(new Error("Database not initialized"));const n=a.transaction(u,"readonly").objectStore(u).openCursor();n.onsuccess=i=>{const o=i.target.result;s(o?{id:o.key,value:o.value}:void 0)},n.onerror=()=>e(n.error)})}function q(s){return new Promise((e,t)=>{if(!a)return t(new Error("Database not initialized"));const i=a.transaction(u,"readwrite").objectStore(u).delete(s);i.onsuccess=()=>e(),i.onerror=()=>t(i.error)})}function g(){return new Promise((s,e)=>{if(!a)return e(new Error("Database not initialized"));const n=a.transaction(u,"readonly").objectStore(u).count();n.onsuccess=()=>s(n.result),n.onerror=()=>e(n.error)})}function S(s,e){return new Promise((t,r)=>{if(!a)return r(new Error("Database not initialized"));const o=a.transaction(u,"readwrite").objectStore(u).put(e,s);o.onsuccess=()=>t(),o.onerror=()=>r(o.error)})}function h(s){return new Promise((e,t)=>{if(!a)return t(new Error("Database not initialized"));const n=a.transaction(u,"readonly").objectStore(u);if(!n.indexNames.contains("priority_idx"))return e(void 0);const o=n.index("priority_idx").openCursor(IDBKeyRange.only(s));o.onsuccess=c=>{const d=c.target.result;e(d?{id:d.primaryKey,value:d.value}:void 0)},o.onerror=()=>t(o.error)})}function v(s,e){return new Promise((t,r)=>{if(!a)return r(new Error("Database not initialized"));const o=a.transaction(u,"readwrite").objectStore(u).openCursor();let c=!1;o.onsuccess=d=>{const l=d.target.result;if(l)if(l.value&&l.value[s]===e){const f=l.delete();f.onsuccess=()=>{c=!0,t(!0)},f.onerror=()=>r(f.error)}else l.continue();else t(c)},o.onerror=()=>r(o.error)})}function k(){return new Promise((s,e)=>{if(!a)return e(new Error("Database not initialized"));const n=a.transaction(u,"readonly").objectStore(u).openCursor(),i=[];n.onsuccess=o=>{const c=o.target.result;c?(i.push({id:c.key,value:c.value}),c.continue()):s(i)},n.onerror=()=>e(n.error)})}function b(){return typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,s=>{const e=Math.random()*16|0;return(s==="x"?e:e&3|8).toString(16)})}const _="rest-sync-lite",z="request-queue";class D{constructor(){this.initialized=null,this._queueSize=0,this.events=new y}async init(){return this.initialized||(this.initialized=m(_,z).then(async()=>{await this.syncSize()})),this.initialized}get size(){return this._queueSize}async enqueueRequest(e){await this.init();const t=e.id||b(),r={...e,id:t,timestamp:Date.now(),retryCount:0};return await p(r),await this.syncSize(),t}async peekNextRequest(){await this.init();let e=await h("high");if(e)return{item:e.value,key:e.id};if(e=await h("normal"),e)return{item:e.value,key:e.id};if(e=await h("low"),e)return{item:e.value,key:e.id};const t=await x();if(t)return{item:t.value,key:t.id}}async dequeueRequest(e){await this.init(),await q(e),await this.syncSize()}async updateRequest(e,t){await this.init(),await S(e,t)}async cancelRequest(e){await this.init();const t=await v("id",e);return t&&await this.syncSize(),t}async getAllItems(){await this.init();const e=await k();return await this.syncSize(),e.map(t=>t.value)}async syncSize(){try{this._queueSize=await g(),this.events.emit("queue:update",void 0)}catch(e){console.error("Failed to sync queue size",e)}}}class R{constructor(){this.events=new y,this._isOnline=!0,this._forcedOffline=!1,typeof window<"u"?(this._isOnline=navigator.onLine,window.addEventListener("online",()=>this.updateState(!0)),window.addEventListener("offline",()=>this.updateState(!1))):typeof self<"u"&&typeof navigator<"u"&&(this._isOnline=navigator.onLine)}isOnline(){return this._forcedOffline?!1:typeof navigator<"u"?navigator.onLine:!0}setOfflineMode(e){if(this._forcedOffline===e)return;this._forcedOffline=e;const t=typeof navigator<"u"?navigator.onLine:!0,r=e?!1:t;this.updateState(r)}onNetworkChange(e){this.events.on("network-change",e)}updateState(e){let t=e;this._forcedOffline&&(t=!1),this._isOnline!==t&&(this._isOnline=t,this.events.emit("network-change",t))}}export{y as E,R as N,D as Q,E as S};
