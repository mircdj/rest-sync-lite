import { initDB, addItem, peekItem, removeItem, updateItem, count, peekFirstByPriority, getAllItems, removeByField } from '../storage/db';
import { generateUUID } from '../utils/uuid';
import { EventEmitter } from '../utils/events';
import type { RequestItem } from './types';

const DB_NAME = 'rest-sync-lite';
const STORE_NAME = 'request-queue';

type QueueEvents = {
    'queue:update': void;
};

export class QueueManager {
    private initialized: Promise<void> | null = null;
    private _queueSize: number = 0;
    public events = new EventEmitter<QueueEvents>();

    /**
     * Ensures the database is initialized.
     */
    async init(): Promise<void> {
        if (!this.initialized) {
            this.initialized = initDB(DB_NAME, STORE_NAME).then(async () => {
                this._queueSize = await count();
                this.events.emit('queue:update', undefined);
            });
        }
        return this.initialized;
    }

    get size(): number {
        return this._queueSize;
    }

    /**
     * Adds a new request to the queue.
     * @param request The request details (excluding managed fields like id, timestamp, retryCount).
     * @returns The generated ID of the queued request.
     */
    async enqueueRequest(
        request: Omit<RequestItem, 'id' | 'timestamp' | 'retryCount'> & { id?: string }
    ): Promise<string> {
        await this.init();

        const id = request.id || generateUUID();
        // Check uniqueness if custom ID? IDB will error if duplicate key?
        // But id here is just a field 'id'. IDB key is generated by autoIncrement?
        // Wait, 'addItem' returns a key. I am storing 'id' as a property.
        // If I want to support cancellation by ID, I should ensure uniqueness.
        // But 'Lite' implies simple. Let's assume user manages IDs correctly if provided.

        const item: RequestItem = {
            ...request, // request may contain 'priority'
            id,
            timestamp: Date.now(),
            retryCount: 0,
        };

        await addItem(item);
        this._queueSize++; // Optimistic update
        this.events.emit('queue:update', undefined);
        return id;
    }

    /**
     * Peeks the next request in the FIFO queue, respecting Priority.
     * Order: High -> Normal -> Low. Within same priority: FIFO.
     */
    async peekNextRequest(): Promise<{ item: RequestItem; key: IDBValidKey } | undefined> {
        await this.init();

        // 1. Try High
        let result = await peekFirstByPriority<RequestItem>('high');
        if (result) return { item: result.value, key: result.id };

        // 2. Try Normal
        result = await peekFirstByPriority<RequestItem>('normal');
        if (result) return { item: result.value, key: result.id };

        // 3. Try Low
        result = await peekFirstByPriority<RequestItem>('low');
        if (result) return { item: result.value, key: result.id };

        // 4. Fallback for legacy items (no priority)
        const fallback = await peekItem<RequestItem>();
        if (fallback) {
            return { item: fallback.value, key: fallback.id };
        }

        return undefined;
    }

    /**
     * Removes a request from the queue by its storage key.
     * @param key The internal storage key returned by peekNextRequest.
     */
    async dequeueRequest(key: IDBValidKey): Promise<void> {
        await this.init();
        await removeItem(key);
        this._queueSize = Math.max(0, this._queueSize - 1);
        this.events.emit('queue:update', undefined);
    }

    /**
     * Updates an item in the queue.
     */
    async updateRequest(key: IDBValidKey, item: RequestItem): Promise<void> {
        await this.init();
        await updateItem(key, item);
    }

    /**
     * Cancels a request by its UUID.
     * Returns true if found and removed, false otherwise.
     */
    async cancelRequest(requestId: string): Promise<boolean> {
        await this.init();
        const result = await removeByField('id', requestId);
        if (result) {
            this._queueSize = Math.max(0, this._queueSize - 1);
            this.events.emit('queue:update', undefined);
        }
        return result;
    }

    /**
     * Retrieves all items in the queue.
     */
    async getAllItems(): Promise<RequestItem[]> {
        await this.init();
        const results = await getAllItems<RequestItem>();
        return results.map(r => r.value);
    }
}

